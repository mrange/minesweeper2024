// Generated with Shader Minifier 1.3.6 (https://github.com/laurentlb/Shader_Minifier/)
#ifndef SHADER_MINIFIER_IMPL
#ifndef SHADER_MINIFIER_HEADER
# define SHADER_MINIFIER_HEADER
# define VAR_fcol "v"
# define VAR_tstate "f"
#endif

#else // if SHADER_MINIFIER_IMPL

// D:\code\github\minesweeper2024\source\minesweeper\shader.frag
"#version 430\n"
 "const float y=1./8;"
 "out vec4 v;"
 "uniform sampler2D f;"
 "const float a=.825/6,s=acos(-1),i=2*s,x=.825/6,m=a,l[12]=float[](5,12,0,17,14,19,16,14,15,18,19,19);"
 "vec2 d=vec2(.75,.075),t[7]=vec2[](vec2(0),vec2(.5,1),vec2(4,2),vec2(10,1),vec2(10,2),vec2(4,1),vec2(10,2));"
 "int C[20]=int[](125,80,79,87,114,55,63,81,127,119,123,62,45,94,47,43,44,251,41,0);"
 "vec3 n(float y)"
 "{"
   "return 1+sin(vec3(-4,3,1)/2+y);"
 "}"
 "float n(vec2 v,vec2 y)"
 "{"
   "float f=(y.x-y.y)/2;"
   "v.x=abs(v.x);"
   "return(v.x<f?"
     "abs(v.y):"
     "length(v-vec2(f,0)))-y.y;"
 "}"
 "vec3 n(vec2 v,vec3 y,vec3 f,float x,float m)"
 "{"
   "vec2 a=abs(v),i=v,s=v,l=sign(v);"
   "if(a.x>.6+d.y||a.y>1.1+d.y)"
     "return vec3(0);"
   "i.y-=1;"
   "float t=round(i.y);"
   "i.y-=t;"
   "s.y=a.y-.5;"
   "s=abs(s);"
   "vec3 z=(C[int(floor(m))]&1<<int(dot(vec2(1,-1)/sqrt(2),s)>0?"
     "3+(l.x+1)/2+l.y+1:"
     "-t))==0?"
     "f:"
     "y;"
   "return z*smoothstep(x,-x,min(n(i,d),n(a.yx-.5,d)));"
 "}"
 "void main()"
 "{"
   "vec4 a=texelFetch(f,ivec2(0,0),0),s=texelFetch(f,ivec2(1,0),0);"
   "vec2 d=a.xy,i=(2*gl_FragCoord.xy-d)/d.yy,C=abs(i),z=i,r=vec2(.75*x,x),w,c,o,u;"
   "float D=a.z/2,F=a.w,H=s.z,G=s.w,p=sqrt(2)/d.y,B=p/m,A=p/.05,E=p/(.25*m),e=sign(z.y);"
   "vec3 I=vec3(0),J=vec3(0,0,D),K=normalize(vec3(i,2));"
   "w=i/m-.5;"
   "z.x-=i.y/5-x*.75/2;"
   "z.y=abs(z.y)-.9;"
   "z/=r;"
   "o=round(z);"
   "c=round(w);"
   "z-=o;"
   "w-=c;"
   "u=w*w*w*w;"
   "z*=r;"
   "z.y*=e;"
   "c+=6;"
   "z/=.05;"
   "for(int L=1;L<9;++L)"
     "{"
       "float g=(-J.x+6*sqrt(L))/abs(K).x;"
       "vec3 M=J+K*g;"
       "vec2 N=M.yz*.02,O=round(N),P=N-O;"
       "if(fract(sin(dot((O+L+.5*sign(K.x)).xy,vec2(12.9898,58.233)))*13758.5453)<.5)"
         "P=vec2(P.y,-P.x);"
       "float Q=smoothstep(-.7,1.,sin(M.z/9+D+L+sign(K.x))),R=abs(min(length(P+.5)-.5,length(P-.5)-.5))-.025;"
       "I+=n(.05*g+D)*exp(-.003*g*g)*.0025/max(abs(R),.003*Q)*Q;"
     "}"
   "if(o.y==0&&abs(o.x-.5)<6)"
     "{"
       "float L=o.x>0?"
         "mod((e>0?"
           "H:"
           "G)*pow(10,o.x-6),10):"
         "l[int(o.x+5+3*(1-e))];"
       "vec3 P=n(2.5+1.5*e+.4*z.y+(o.x<1?"
         "0:"
         "3));"
       "I+=n(z,P,P*.075,A,L);"
     "}"
   "if(max(C.x,C.y)<.825)"
     "{"
       "vec4 P=texelFetch(f,ivec2(c.x,c.y+1),0);"
       "float L=P.z,O=P.w,R=pow(dot(u,u),1./8)-.45,N=smoothstep(O+1./2,O+1./8,F),M=smoothstep(L,L+y,F);"
       "vec3 g=tanh(I*8)/8;"
       "for(int Q=0;Q<2;++Q)"
         "{"
           "float S=Q==0?"
             "P.y:"
             "P.x,T=Q==0?"
             "1-M:"
             "M,U=abs(length(w)-N/9);"
           "vec2 V=t[int(S)];"
           "for(float W=0;W<V.y;++W)"
             "U=min(abs(U-.1),U);"
           "vec3 W=(.2+n(2-S))*(V.x*.005/max(U,.003));"
           "if(S<1)"
             "{"
               "vec2 X=w/.25;"
               "X.x+=-X.y/8;"
               "vec3 Y=n(S/2-X.y/2),Z=Y/20;"
               "if(S<0)"
                 "g+=n(X,Y,Z,E,-S);"
             "}"
           "else"
             " g=mix(g,W,T*smoothstep(B,-B,R));"
         "}"
       "I=mix(I,g,smoothstep(B,-B,R));"
       "I=mix(I,mix(n(3.+i.y)/3,vec3(1),N),smoothstep(B,-B,abs(R)-1./80));"
     "}"
   "v=vec4(sqrt(tanh(I)),1);"
 "}",

#endif
