// Generated with Shader Minifier 1.3.6 (https://github.com/laurentlb/Shader_Minifier/)
#ifndef SHADER_MINIFIER_IMPL
#ifndef SHADER_MINIFIER_HEADER
# define SHADER_MINIFIER_HEADER
# define VAR_fcol "v"
# define VAR_state "a"
#endif

#else // if SHADER_MINIFIER_IMPL

// D:\code\github\minesweeper2024\source\minesweeper\shader.frag
"#version 430\n"
 "const float y=1./8;"
 "out vec4 v;"
 "uniform vec4[146] a;"
 "const float m=.825/6,s=acos(-1),f=2*s,x=.825/6,w=m,l[12]=float[](5,12,0,17,14,19,16,14,15,18,19,19);"
 "vec2 d=vec2(.75,.075),r[7]=vec2[](vec2(0),vec2(.5,1),vec2(4,2),vec2(10,1),vec2(10,2),vec2(4,1),vec2(10,2));"
 "int t[20]=int[](125,80,79,87,114,55,63,81,127,119,123,62,45,94,47,43,44,251,41,0);"
 "vec3 n(float y)"
 "{"
   "return 1+sin(vec3(-4,3,1)/2+y);"
 "}"
 "float n(vec2 v,vec2 y)"
 "{"
   "v.x=abs(v.x);"
   "float f=max(y.x-y.y,0)/2;"
   "return(v.x<f?"
     "abs(v.y):"
     "length(v-vec2(f,0)))-y.y;"
 "}"
 "vec3 n(vec2 v,vec3 y,vec3 f,float m,float x)"
 "{"
   "vec2 a=abs(v),s=v,i=v,l=sign(v);"
   "if(a.x>.6+d.y||a.y>1.1+d.y)"
     "return vec3(0);"
   "s.y-=1;"
   "float r=round(s.y);"
   "s.y-=r;"
   "i.y=a.y-.5;"
   "i=abs(i);"
   "vec3 w=(t[int(floor(x))]&1<<int(dot(vec2(1,-1)/sqrt(2),i)>0?"
     "3+(l.x+1)/2+l.y+1:"
     "-r))==0?"
     "f:"
     "y;"
   "return w*smoothstep(m,-m,min(n(s,d),n(a.yx-.5,d)));"
 "}"
 "void main()"
 "{"
   "vec2 d=a[0].xy,s=(2*gl_FragCoord.xy-d)/d.yy,f=abs(s),i=s,m=vec2(.75*x,x),z,c,t,o;"
   "float C=a[0].z/2,F=a[1].z,I=a[0].w,H=a[1].w,p=sqrt(2)/d.y,E=p/w,D=p/.05,B=p/(.25*w),e=sign(i.y),u;"
   "vec3 g=vec3(0),A=vec3(0,0,C),G=normalize(vec3(s,2));"
   "z=s/w-.5;"
   "i.x-=s.y/5-x*.75/2;"
   "i.y=abs(i.y)-.9;"
   "i/=m;"
   "t=round(i);"
   "c=round(z);"
   "i-=t;"
   "z-=c;"
   "o=z*z*z*z;"
   "i*=m;"
   "i.y*=e;"
   "c+=6;"
   "i/=.05;"
   "u=c.x+c.y*12+2;"
   "for(int J=1;J<9;++J)"
     "{"
       "float K=(-A.x+6*sqrt(J))/abs(G).x;"
       "vec3 L=A+G*K;"
       "vec2 M=L.yz*.02,N=round(M),O=M-N;"
       "if(fract(sin(dot((N+J+.5*sign(G.x)).xy,vec2(12.9898,58.233)))*13758.5453)<.5)"
         "O=vec2(O.y,-O.x);"
       "float P=smoothstep(-.7,1.,sin(L.z/9+C+J+sign(G.x))),Q=abs(min(length(O+.5)-.5,length(O-.5)-.5))-.025;"
       "g+=n(.05*K+C)*exp(-.003*K*K)*.0025/max(abs(Q),.003*P)*P;"
     "}"
   "if(t.y==0&&abs(t.x-.5)<6)"
     "{"
       "float J=t.x>0?"
         "mod((e<0?"
           "H:"
           "F)*pow(10,t.x-6),10):"
         "l[int(t.x+5+3*(1-e))];"
       "vec3 K=n(2.5+1.5*e+.4*i.y+(t.x<1?"
         "0:"
         "3));"
       "g+=n(i,K,K*.075,D,J);"
     "}"
   "if(max(f.x,f.y)<.825)"
     "{"
       "vec4 L=a[int(u)];"
       "float J=L.z,O=L.w,K=pow(dot(o,o),1./8)-.45,N=smoothstep(O+1./2,O+1./8,I),Q=smoothstep(J,J+y,I);"
       "vec3 M=tanh(8*g)/8;"
       "for(int P=0;P<2;++P)"
         "{"
           "float R=P==0?"
             "L.y:"
             "L.x,S=P==0?"
             "1-Q:"
             "Q,T=abs(length(z)-N/9);"
           "vec2 U=r[int(R)];"
           "for(float V=0;V<U.y;++V)"
             "T=min(abs(T-.1),T);"
           "vec3 V=(.2+n(2-R))*(U.x*.005/max(T,.003));"
           "if(R<1)"
             "{"
               "vec2 W=z/.25;"
               "W.x+=-W.y/8;"
               "vec3 X=n(R/2-W.y/2),Y=X/20;"
               "if(R<0)"
                 "M+=n(W,X,Y,B,-R);"
             "}"
           "else"
             " M=mix(M,V,S*smoothstep(E,-E,K));"
         "}"
       "g=mix(g,M,smoothstep(E,-E,K));"
       "g=mix(g,mix(n(3.+s.y)/4,vec3(1),N),smoothstep(E,-E,abs(K)-1./80));"
     "}"
   "v=vec4(sqrt(tanh(g)),1);"
 "}",

#endif
