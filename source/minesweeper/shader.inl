// Generated with Shader Minifier 1.3.6 (https://github.com/laurentlb/Shader_Minifier/)
#ifndef SHADER_MINIFIER_IMPL
#ifndef SHADER_MINIFIER_HEADER
# define SHADER_MINIFIER_HEADER
# define VAR_fcol "v"
# define VAR_state "a"
#endif

#else // if SHADER_MINIFIER_IMPL

// D:\code\github\minesweeper2024\source\minesweeper\shader.frag
"#version 430\n"
 "const float y=1./8;"
 "out vec4 v;"
 "uniform vec4[146] a;"
 "const float m=.825/6,s=acos(-1),f=2*s,x=.825/6,w=m,l[12]=float[](5,12,0,17,14,19,16,14,15,18,19,19);"
 "vec2 d=vec2(.75,.075),r[7]=vec2[](vec2(0),vec2(.5,0),vec2(4,2),vec2(10,1),vec2(10,2),vec2(4,1),vec2(10,1));"
 "int i[20]=int[](125,80,79,87,114,55,63,81,127,119,123,62,45,94,47,43,44,251,41,0);"
 "vec3 t(float y)"
 "{"
   "return 1+sin(vec3(-4,3,1)/2+y);"
 "}"
 "vec2 t(inout vec2 v,vec2 y)"
 "{"
   "vec2 f=floor((v+y/2)/y);"
   "v=mod(v+y/2,y)-y/2;"
   "return f;"
 "}"
 "float n(vec2 v)"
 "{"
   "v*=v;"
   "v*=v;"
   "return pow(dot(v,v),1./8)-.45;"
 "}"
 "float n(vec2 v,vec2 y)"
 "{"
   "v.x=abs(v.x);"
   "float f=max(y.x-y.y,0)/2;"
   "return(v.x<f?"
     "abs(v.y):"
     "length(v-vec2(f,0)))-y.y;"
 "}"
 "vec3 n(vec2 v,vec3 y,vec3 f,float m,float x)"
 "{"
   "vec2 a=abs(v),s=v,r=v,l=sign(v);"
   "if(a.x>.6+d.y||a.y>1.1+d.y)"
     "return vec3(0);"
   "s.y-=1;"
   "float t=round(s.y);"
   "s.y-=t;"
   "r.y=a.y-.5;"
   "r=abs(r);"
   "vec3 p=(i[int(floor(x))]&1<<int(dot(vec2(1,-1)/sqrt(2),r)>0?"
     "3+(l.x+1)/2+l.y+1:"
     "-t))==0?"
     "f:"
     "y;"
   "return p*smoothstep(m,-m,min(n(s,d),n(a.yx-.5,d)));"
 "}"
 "void main()"
 "{"
   "vec2 f=a[0].xy,s=(2*gl_FragCoord.xy-f)/f.yy,d=s,m=s,i=s;"
   "float p=a[0].z/2,C=a[1].z,F=a[0].w,K=a[1].w,z=sqrt(2)/f.y,I=z/w,H=z/.05,G=z/(.25*w),e=sign(i.y);"
   "vec3 c=vec3(0),B=vec3(0,0,p),A=normalize(vec3(s,2));"
   "for(int o=1;o<10;++o)"
     "{"
       "float g=(-B.x+6*sqrt(o))/abs(A).x;"
       "vec3 D=B+A*g;"
       "vec2 E=D.yz*.02,J=round(E),L=E-J;"
       "if(fract(sin(dot((J+o+.5*sign(A.x)).xy,vec2(12.9898,58.233)))*13758.5453)<.5)"
         "L=vec2(L.y,-L.x);"
       "float M=smoothstep(-.7,1.,sin(D.z/9+p+o+sign(A.x))),N=abs(min(length(L+.5)-.5,length(L-.5)-.5))-.025;"
       "c+=t(.05*g+p)*exp(-.003*g*g)*.0025/max(abs(N),.003*M)*M;"
     "}"
   "m=m/w-.5;"
   "i.x-=s.y/5-x*.75/2;"
   "i.y=abs(i.y)-.9;"
   "vec2 L=t(i,vec2(.75*x,x)),o=round(m);"
   "i.y*=e;"
   "m-=o;"
   "o+=6;"
   "i/=.05;"
   "float E=o.x+o.y*12+2;"
   "if(L.y==0&&abs(L.x-.5)<6)"
     "{"
       "vec3 g=t(2.5+1.5*e+.4*i.y+(L.x<1?"
         "0:"
         "3));"
       "c+=n(i,g,g*.075,H,L.x>0?"
         "mod((e<0?"
           "K:"
           "C)*pow(10,L.x-6),10):"
         "l[int(L.x+5+3*(1-e))]);"
     "}"
   "if(max(abs(d).x,abs(d).y)<.825)"
     "{"
       "vec4 D=a[int(E)];"
       "float g=D.z,J=D.w,N=n(m),M=smoothstep(J+1./2,J+1./8,F),O=smoothstep(g,g+y,F);"
       "vec3 P=tanh(8*c)/8;"
       "for(int u=0;u<2;++u)"
         "{"
           "float Q=u==0?"
             "D.y:"
             "D.x,R=u==0?"
             "1-O:"
             "O,S=abs(length(m)-M/9);"
           "vec2 T=r[int(Q)];"
           "for(float U=0;U<T.y;++U)"
             "S=min(abs(S-.1),S);"
           "vec3 U=(.2+t(2-Q))*(T.x*.005/max(S,.003));"
           "if(Q<1)"
             "{"
               "vec2 V=m/.25;"
               "V.x+=-V.y/8;"
               "vec3 W=t(Q/2-V.y/2),X=W/20;"
               "if(Q<0)"
                 "P+=n(V,W,X,G,-Q);"
             "}"
           "else"
             " P=mix(P,U,R*smoothstep(I,-I,N));"
         "}"
       "c=mix(c,P,smoothstep(I,-I,N));"
       "c=mix(c,mix(t(3.+s.y)/4,vec3(1),M),smoothstep(I,-I,abs(N)-1./80));"
     "}"
   "v=vec4(sqrt(tanh(c)),1);"
 "}",

#endif
